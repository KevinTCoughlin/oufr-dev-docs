import * as Mustache from 'mustache';
import * as path from 'path';

import { IYamlTocItem } from '@microsoft/api-documenter/lib/yaml/IYamlTocFile';
import { FileSystem, JsonFile } from '@microsoft/node-core-library';
import { categories } from './categories';
// import { fabricPackageJsonFile } from './get-fabric-version';
import { IInjectionPagePaths, ITocConfig } from './interfaces';
import { deepPaths, outputPaths, templatePaths, tocPaths } from './pathConsts';

const URL_NORMALIZE_PART = '(https://developer.microsoft.com/en-us/fabric#/';

const CONFIG_OUTPUT_PATH = path.resolve(__dirname, '..', 'config', 'api-documenter.json');

const GET_STARTED_FILES = [
  'GetStartedOverview',
  'GetStartedDevelopExisting',
  'GetStartedDevelopSimple',
  'GetStartedNextSteps',
  'GetStartedDevelopCore',
  'GetStartedDesign',
];

const RESOURCES_FILES = [
  'ResourcesOverview',
  'ResourcesDesignResources',
  'ResourcesDeveloperResources',
  'ResourcesContributionProcess',
];

/**
 * Function that will be running every time before calling api-documenter and generate a json file along with writing example files.
 */
function generateConfig(categoriesSource: any) {
  const tocConfig: ITocConfig = {
    items: [
      {
        name: 'Get Started',
        href: tocPaths.getStarted,
      },
      {
        name: 'Office UI Fabric React',
        uid: 'office-ui-fabric-react',
        items: [],
      },
      {
        name: 'Resources',
        href: tocPaths.resources,
      },
    ],
  };

  const nonEmptyCategoryNodeNames: string[] = ['References'];

  // delete unnecessary navigation items for docs.microsoft but present on the Fabric website
  delete categoriesSource['Fluent Theme'];
  delete categoriesSource['Other'];

  const topCategories = Object.keys(categoriesSource);

  // First loop iterates over controls categories like: 'Basic Inputs', 'Galleries & Pickers',...
  for (const topCategory of topCategories) {
    // Creating a node for each category
    const topCategoryNode: IYamlTocItem = {
      name: topCategory,
      items: [],
    };

    // Since we don't use package level TOC generated by default, most of the API items in 'References'
    // will reference the package yaml file which is omitted with our custom implementation of TOC,
    // so we inject those here in references manually so that they already are included in the api-documenter.json config file.
    if (topCategory === 'References' && topCategoryNode && topCategoryNode.items) {
      topCategoryNode.items.push(
        {
          name: 'merge-styles',
          uid: 'merge-styles',
        },
        {
          name: 'styling',
          uid: 'styling',
        },
        {
          name: 'utilities',
          uid: 'utilities',
        },
      );
    }

    // All the controls under a category that we are looping over on each iteration
    const topCategoryItems = Object.keys(categoriesSource[topCategory]);

    // Second inner loop iterates over each control in each category of the outer loop
    for (const topCategoryItem of topCategoryItems) {
      // Each item represents a component. Creating a reference pointer.
      const item: IYamlTocItem = {
        name: topCategoryItem,
        items: [],
      };

      // Removing this item for now as it has no api-items or examples and results in  broken link on docs.microsoft
      if (topCategoryItem === 'Themes') {
        continue;
      }

      // GetStarted page generation
      injectPage(GET_STARTED_FILES, {
        base: deepPaths.getStartedDocs,
        template: templatePaths.getStarted,
        output: outputPaths.getStarted,
      });

      // Resources page generation
      injectPage(RESOURCES_FILES, {
        base: deepPaths.resourcesDocs,
        template: templatePaths.resources,
        output: outputPaths.resources,
      });

      // Overview nodes injections in TOC and files generation
      injectOverview(topCategoryItem, item);

      // Examples nodes injection in TOC and files generation
      injectExamples(categoriesSource, topCategory, topCategoryItem, item);

      // pushing the item into it's top category node
      if (topCategoryNode.items) {
        topCategoryNode.items.push(item);
      }

      // adding the name of the node to the nonEmptyCategoryNodeNames array now that we also push examples
      nonEmptyCategoryNodeNames.push(topCategoryItem);
    }

    if (tocConfig.items[1] && tocConfig.items[1].items) {
      tocConfig.items[1].items.push(topCategoryNode);
    }
  }

  const config = {
    tableOfContents: {
      tocConfig,
      catchAllCategory: 'References',
      categoryInlineTag: 'docCategory',
      nonEmptyCategoryNodeNames,
    },
  };

  // writing file
  JsonFile.save(config, CONFIG_OUTPUT_PATH);
}

/**
 * Helper function to inject nodes in the TOC and create files for the `Overview` page
 */
function injectOverview(topCategoryItem: string, itemReference: IYamlTocItem): void {
  const itemPath: string = resolveSpecialCases(topCategoryItem, `${deepPaths.fabricDocs}/${topCategoryItem}/docs`);

  // Content of all 3 files Overview, Dos and Donts that we want to concatenate in one file
  const overview: string =
    normalizeContentUrls(readFile(`${itemPath}/${resolveSpecialCases(topCategoryItem)}Overview.md`)) ||
    'Coming soon...';
  const dos: string =
    normalizeContentUrls(readFile(`${itemPath}/${resolveSpecialCases(topCategoryItem)}Dos.md`)) || 'Coming soon...';
  const donts: string =
    normalizeContentUrls(readFile(`${itemPath}/${resolveSpecialCases(topCategoryItem)}Donts.md`)) || 'Coming soon...';

  const pushToTOC = () => {
    itemReference.items!.push({
      name: 'Overview',
      href: `${tocPaths.overview}/${topCategoryItem}Overview.md`,
    });
  };

  fillTemplate(
    templatePaths.overview,
    { overview, dos, donts, itemName: topCategoryItem },
    `${outputPaths.overview}/${topCategoryItem}Overview.md`,
    pushToTOC,
  );
}

/**
 * Helper function to inject example page nodes into the TOC and also calls the write file helper function.
 */
function injectExamples(
  categoriesSource: any,
  topCategory: string,
  topCategoryItem: string,
  itemReference: IYamlTocItem,
): void {
  const itemNameNormalized = topCategoryItem.toLowerCase();

  // In case a component has it's examples split into sub-pages then we handle it differently
  if (categoriesSource[topCategory][topCategoryItem].subPages) {
    const examplesNodeReference: IYamlTocItem = {
      name: `${topCategoryItem} Examples`,
      items: [],
    };

    // special case for DetailsList having an example page not listed under sub-pages but we still want it to be included.
    if (topCategoryItem === 'DetailsList') {
      const writingFinished: boolean = writeExampleFile(
        'DetailsList Example',
        'detailslist',
        'detailslist/detailslist',
      );

      if (writingFinished) {
        examplesNodeReference.items!.push({
          name: 'Details List',
          href: `${tocPaths.example}/${itemNameNormalized}/detailslist.md`,
        });
      }
    }

    const subPages = categoriesSource[topCategory][topCategoryItem].subPages;

    for (const key in subPages) {
      if (subPages.hasOwnProperty(key)) {
        const name: string = subPages[key].title || key;
        const pathAndUrl: string = `${subPages[key].url || key.toLowerCase()}`;

        // generate a markdown file
        const writingFinished: boolean = writeExampleFile(
          `${topCategoryItem} ${name} Example`,
          `${itemNameNormalized}/${pathAndUrl}`,
        );

        if (writingFinished) {
          examplesNodeReference.items!.push({
            name,
            href: `${tocPaths.example}/${itemNameNormalized}/${pathAndUrl}.md`,
          });
        }
      }
    }

    itemReference.items!.push(examplesNodeReference);
  } else {
    // generate a markdown file
    const writingFinished: boolean = writeExampleFile(`${topCategoryItem} Examples`, itemNameNormalized);

    // push an example node to the items array of the component node
    if (writingFinished) {
      itemReference.items!.push({
        name: `${topCategoryItem} Examples`,
        href: `${tocPaths.example}/${itemNameNormalized}.md`,
      });
    }
  }
}

/**
 * Helper function to handle the example files generation.
 */
function writeExampleFile(componentName: string, componentUrl: string, fileLocationPath?: string): boolean {
  return fillTemplate(
    templatePaths.example,
    { componentName, componentUrl },
    `${outputPaths.example}/${fileLocationPath || componentUrl}.md`,
  );
}

/**
 * Helper function to resolve some special cases for the path of the markdown files needed for Overview pages.
 * TODO: might need to revisit this idea and replace it with something similar to https://www.npmjs.com/package/glob
 * but for the moment using as a bandage :)
 */
function resolveSpecialCases(topCategoryItem: string, fullPath?: string): string {
  const specialCases: string[] = ['Keytips', 'Selection', 'PeoplePicker'];

  if (specialCases.indexOf(topCategoryItem) !== -1) {
    switch (topCategoryItem) {
      case 'Keytips':
        if (fullPath) return fullPath.replace('Keytips', 'Keytip');
        else return 'Keytip';
      case 'Selection':
        if (fullPath) return fullPath.replace('components', 'utilities').replace('Selection', 'selection');
        else return topCategoryItem;
      case 'PeoplePicker':
        if (fullPath) return fullPath.replace('PeoplePicker', 'pickers/PeoplePicker');
        else return topCategoryItem;
      default:
        break;
    }
  }

  return fullPath || topCategoryItem;
}

/**
 * Helper function to generate markdown pages.
 */
function injectPage(filesList: string[], paths: IInjectionPagePaths): void {
  const sections: { [key: string]: string } = {};

  // sections['fabricPackageVersion'] = fabricPackageJsonFile.version;

  filesList.forEach(file => {
    sections[file] = sanitizeContent(readFile(`${paths.base}/${file}.md`));
  });

  fillTemplate(paths.template, sections, paths.output);
}

/**
 * Helper function to remove duplication of code when writing a file through a mustache.js template.
 */
function fillTemplate(templatePath: string, templateData: any, outputPath: string, cb?: () => void): boolean {
  const exampleTemplate: string = readFile(templatePath);
  const fileData: string = Mustache.render(exampleTemplate, templateData);

  return writeMarkdownFile(outputPath, fileData, cb);
}

/**
 * Helper function to aid in writing the markdown files needed for pages.
 */
function writeMarkdownFile(filePath: string, fileData: string, cb?: () => void): boolean {
  try {
    FileSystem.writeFile(filePath, fileData, {
      ensureFolderExists: true,
    });

    if (cb) {
      cb();
    }

    return true;
  } catch (error) {
    console.log(error);
  }
  return false;
}

/**
 * Helper function to aid in reading the files.
 */
function readFile(markdownFilePath: string): string {
  try {
    return FileSystem.readFile(markdownFilePath);
  } catch (error) {
    console.log(`Can not find a file at path: ${markdownFilePath}`);
  }
  return '';
}

/**
 * Helper function to replace specific urls in string.
 */
function normalizeContentUrls(content: string): string {
  if (!content) return content;
  return content.replace(/(\(#\/)/gi, URL_NORMALIZE_PART);
}

function sanitizeContent(content: string): string {
  return normalizeContentUrls(
    content
      .replace(/<ul class="md-list--flex">\s/g, '')
      .replace(/\s\s<li class="mdut--half">|\s\s<li class="mdut--full">/g, '- ')
      .replace(/<\/li>/g, '')
      .replace(/<\/ul>\s/g, ''),
  );
}

// Start generation.
generateConfig(categories);
